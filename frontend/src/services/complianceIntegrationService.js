/**
 * COMPLIANCE INTEGRATION SERVICE
 * Servicio que integra el RAT Intelligence Engine con la aplicaci√≥n existente
 * SIN MODIFICAR la interfaz actual del RAT Producci√≥n
 */

import ratIntelligenceEngine from './ratIntelligenceEngine.js';

class ComplianceIntegrationService {
  constructor() {
    this.evaluations = new Map(); // Cache de evaluaciones
    this.listeners = new Set(); // Listeners para cambios
    this.autoEvaluationEnabled = true;
  }

  /**
   * INTEGRACI√ìN TRANSPARENTE: Intercepta el guardado de RAT
   * y ejecuta autom√°ticamente la evaluaci√≥n de inteligencia
   */
  async interceptRATSave(ratData, originalSaveFunction) {
    try {
      // 1. Ejecutar el guardado original (sin modificar funcionalidad existente)
      const savedRAT = await originalSaveFunction(ratData);
      
      // 2. Ejecutar evaluaci√≥n autom√°tica en background
      if (this.autoEvaluationEnabled) {
        this.evaluateRATInBackground(savedRAT);
      }
      
      return savedRAT;
    } catch (error) {
      console.error('‚ùå Error en integraci√≥n de cumplimiento:', error);
      // Si falla la evaluaci√≥n, NO fallar el guardado original
      return await originalSaveFunction(ratData);
    }
  }

  /**
   * EVALUACI√ìN EN BACKGROUND
   * Ejecuta la evaluaci√≥n sin bloquear la UI existente
   */
  async evaluateRATInBackground(ratData) {
    try {
      console.log('üîÑ Iniciando evaluaci√≥n autom√°tica para:', ratData.nombre_actividad);
      
      const evaluation = await ratIntelligenceEngine.evaluateRATActivity(ratData);
      
      // Guardar evaluaci√≥n en cache local
      this.evaluations.set(ratData.id, evaluation);
      
      // Notificar a listeners (para dashboard, alertas, etc.)
      this.notifyEvaluationComplete(ratData.id, evaluation);
      
      // Auto-generar documentos si est√° habilitado
      await this.processAutoGenerations(evaluation);
      
      console.log('‚úÖ Evaluaci√≥n completada:', {
        rat_id: ratData.id,
        score: evaluation.compliance_score,
        triggers: evaluation.triggers.length,
        alerts: evaluation.compliance_alerts.length
      });

    } catch (error) {
      console.error('‚ùå Error en evaluaci√≥n background:', error);
    }
  }

  /**
   * PROCESAMIENTO DE AUTO-GENERACIONES
   * Crea autom√°ticamente EIPDs y DPAs cuando se requieren
   */
  async processAutoGenerations(evaluation) {
    for (const trigger of evaluation.triggers) {
      if (trigger.auto_generate) {
        switch (trigger.type) {
          case 'EIPD_OBLIGATORIA':
            await this.autoGenerateEIPD(evaluation.rat_id, trigger);
            break;
            
          case 'DPA_REQUERIDO':
            await this.autoGenerateDPA(evaluation.rat_id, trigger);
            break;
            
          default:
            console.log('‚ÑπÔ∏è Trigger no auto-generado:', trigger.type);
        }
      }
    }
  }

  /**
   * AUTO-GENERACI√ìN DE EIPD
   */
  async autoGenerateEIPD(ratId, trigger) {
    try {
      console.log('ü§ñ Generando EIPD autom√°tica para RAT:', ratId);
      
      const eipd = {
        id: this.generateId('eipd'),
        rat_id: ratId,
        tipo: 'automatica',
        trigger_reason: trigger.reason,
        legal_basis: trigger.legal_basis,
        estado: 'borrador_automatico',
        fecha_creacion: new Date().toISOString(),
        
        // Estructura base para EIPD
        secciones: {
          descripcion_tratamiento: {
            completado: false,
            auto_populated: true,
            contenido: 'Auto-generado desde RAT'
          },
          evaluacion_necesidad: {
            completado: true,
            auto_populated: true,
            contenido: trigger.reason
          },
          descripcion_riesgos: {
            completado: false,
            auto_populated: false,
            contenido: ''
          },
          medidas_mitigacion: {
            completado: false,
            auto_populated: false,
            contenido: ''
          },
          consulta_delegado: {
            completado: false,
            auto_populated: false,
            contenido: ''
          }
        }
      };
      
      // Guardar EIPD en almacenamiento local por ahora
      await this.saveDocument('eipd', eipd);
      
      console.log('‚úÖ EIPD generada autom√°ticamente:', eipd.id);
      
    } catch (error) {
      console.error('‚ùå Error generando EIPD:', error);
    }
  }

  /**
   * AUTO-GENERACI√ìN DE DPA
   */
  async autoGenerateDPA(ratId, trigger) {
    try {
      console.log('ü§ñ Generando DPA autom√°tico para proveedor:', trigger.proveedor?.nombre);
      
      const dpa = {
        id: this.generateId('dpa'),
        rat_id: ratId,
        proveedor_id: trigger.proveedor?.id,
        proveedor_nombre: trigger.proveedor?.nombre,
        tipo: 'automatico',
        trigger_reason: trigger.reason,
        legal_basis: trigger.legal_basis,
        estado: 'borrador_automatico',
        fecha_creacion: new Date().toISOString(),
        
        // Clausulas base para DPA
        clausulas: {
          objeto_tratamiento: {
            completado: false,
            auto_populated: true,
            contenido: 'Auto-generado desde RAT'
          },
          duracion_tratamiento: {
            completado: false,
            auto_populated: true,
            contenido: 'Seg√∫n plazo definido en RAT'
          },
          obligaciones_encargado: {
            completado: true,
            auto_populated: true,
            contenido: this.getStandardDPAClauses()
          },
          medidas_seguridad: {
            completado: false,
            auto_populated: false,
            contenido: ''
          },
          subencargados: {
            completado: false,
            auto_populated: false,
            contenido: ''
          }
        }
      };
      
      // Guardar DPA en almacenamiento local
      await this.saveDocument('dpa', dpa);
      
      console.log('‚úÖ DPA generado autom√°ticamente:', dpa.id);
      
    } catch (error) {
      console.error('‚ùå Error generando DPA:', error);
    }
  }

  /**
   * API P√öBLICA: Obtener evaluaci√≥n de un RAT
   */
  async getEvaluation(ratId) {
    // Buscar en cache primero
    if (this.evaluations.has(ratId)) {
      return this.evaluations.get(ratId);
    }
    
    // Si no existe, buscar en storage
    const stored = await this.getStoredEvaluation(ratId);
    if (stored) {
      this.evaluations.set(ratId, stored);
      return stored;
    }
    
    return null;
  }

  /**
   * API P√öBLICA: Obtener dashboard de cumplimiento
   */
  async getComplianceDashboard() {
    const allEvaluations = Array.from(this.evaluations.values());
    
    const dashboard = {
      resumen: {
        total_actividades: allEvaluations.length,
        alto_riesgo: allEvaluations.filter(e => e.risk_assessment.level === 'alto').length,
        eipds_requeridas: allEvaluations.filter(e => 
          e.triggers.some(t => t.type === 'EIPD_OBLIGATORIA')).length,
        dpas_requeridos: allEvaluations.reduce((total, e) => 
          total + e.triggers.filter(t => t.type === 'DPA_REQUERIDO').length, 0),
        score_promedio: this.calculateAverageScore(allEvaluations)
      },
      
      alertas_criticas: this.getCriticalAlerts(allEvaluations),
      
      proximas_acciones: this.getUpcomingActions(allEvaluations),
      
      tendencias: {
        mejora_cumplimiento: this.calculateComplianceTrend(),
        nuevos_riesgos: this.getNewRisks(),
        documentos_vencidos: this.getExpiringDocuments()
      }
    };
    
    return dashboard;
  }

  /**
   * API P√öBLICA: Forzar evaluaci√≥n manual de un RAT
   */
  async forceEvaluation(ratData) {
    console.log('üîÑ Forzando evaluaci√≥n manual para:', ratData.nombre_actividad);
    
    const evaluation = await ratIntelligenceEngine.evaluateRATActivity(ratData);
    this.evaluations.set(ratData.id, evaluation);
    this.notifyEvaluationComplete(ratData.id, evaluation);
    
    return evaluation;
  }

  /**
   * API P√öBLICA: Configuraci√≥n del servicio
   */
  configure(options = {}) {
    if (options.autoEvaluationEnabled !== undefined) {
      this.autoEvaluationEnabled = options.autoEvaluationEnabled;
    }
    
    console.log('‚öôÔ∏è Compliance Integration Service configurado:', {
      autoEvaluationEnabled: this.autoEvaluationEnabled
    });
  }

  /**
   * API P√öBLICA: Suscribirse a eventos de evaluaci√≥n
   */
  subscribe(callback) {
    this.listeners.add(callback);
    
    return () => {
      this.listeners.delete(callback);
    };
  }

  // ========== FUNCIONES AUXILIARES ==========

  notifyEvaluationComplete(ratId, evaluation) {
    this.listeners.forEach(callback => {
      try {
        callback({
          type: 'evaluation_complete',
          rat_id: ratId,
          evaluation: evaluation
        });
      } catch (error) {
        console.error('‚ùå Error notificando listener:', error);
      }
    });
  }

  async saveDocument(type, document) {
    // Por ahora usar localStorage, despu√©s integrar con backend
    const key = `compliance_${type}_${document.id}`;
    localStorage.setItem(key, JSON.stringify(document));
  }

  async getStoredEvaluation(ratId) {
    try {
      const key = `compliance_evaluation_${ratId}`;
      const stored = localStorage.getItem(key);
      return stored ? JSON.parse(stored) : null;
    } catch (error) {
      console.error('‚ùå Error recuperando evaluaci√≥n:', error);
      return null;
    }
  }

  getStandardDPAClauses() {
    return `
El Encargado se compromete a:
1. Tratar los datos √∫nicamente seg√∫n instrucciones documentadas del Responsable
2. Garantizar confidencialidad del personal autorizado
3. Implementar medidas t√©cnicas y organizativas apropiadas
4. Notificar brechas de seguridad dentro de 72 horas
5. Asistir al Responsable en el cumplimiento de derechos de titulares
6. Eliminar o devolver datos al finalizar la relaci√≥n contractual
7. Cumplir con todos los requisitos de la Ley 21.719
    `.trim();
  }

  calculateAverageScore(evaluations) {
    if (evaluations.length === 0) return 0;
    const total = evaluations.reduce((sum, e) => sum + e.compliance_score, 0);
    return Math.round(total / evaluations.length);
  }

  getCriticalAlerts(evaluations) {
    const alerts = [];
    evaluations.forEach(evaluation => {
      evaluation.compliance_alerts
        .filter(alert => alert.severity === 'error')
        .forEach(alert => alerts.push({
          rat_id: evaluation.rat_id,
          ...alert
        }));
    });
    return alerts.slice(0, 5); // Top 5 alertas cr√≠ticas
  }

  getUpcomingActions(evaluations) {
    const actions = [];
    evaluations.forEach(evaluation => {
      evaluation.triggers
        .filter(trigger => trigger.auto_generate)
        .forEach(trigger => actions.push({
          rat_id: evaluation.rat_id,
          action: trigger.action_required,
          priority: trigger.priority,
          type: trigger.type
        }));
    });
    return actions.slice(0, 10); // Top 10 acciones
  }

  calculateComplianceTrend() {
    // TODO: Implementar an√°lisis de tendencias hist√≥ricas
    return { direction: 'up', percentage: 5.2 };
  }

  getNewRisks() {
    // TODO: Identificar nuevos riesgos en las √∫ltimas evaluaciones
    return [];
  }

  getExpiringDocuments() {
    // TODO: Identificar documentos pr√≥ximos a vencer
    return [];
  }

  generateId(prefix) {
    return `${prefix}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
}

// Instancia singleton
const complianceIntegrationService = new ComplianceIntegrationService();

export default complianceIntegrationService;