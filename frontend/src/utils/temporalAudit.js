import supabase from '../config/supabaseClient';

class TemporalAudit {
  constructor() {
    this.trackingEnabled = true;
    this.maxHistorySize = 1000;
  }

  async initializeRAT(ratData, userId, tenantId) {
    try {
      const auditEntry = {
        rat_id: ratData.id,
        user_id: userId,
        tenant_id: tenantId,
        operation: 'create',
        timestamp: new Date().toISOString(),
        snapshot_before: null,
        snapshot_after: this.sanitizeSnapshot(ratData),
        changed_fields: Object.keys(ratData),
        change_summary: 'RAT inicial creado',
        version_number: 1,
        session_id: this.generateSessionId(),
        metadata: {
          creation_context: 'user_interface',
          initial_state: true
        }
      };

      const { error } = await supabase
        .from('rat_audit_trail')
        .insert(auditEntry);

      if (error) throw error;

      return { success: true, auditId: auditEntry.id };
    } catch (error) {
      console.error('Error iniciando auditoría RAT');
      return { success: false, error: error.message };
    }
  }

  async trackRATChange(ratId, oldData, newData, userId, tenantId, changeContext = {}) {
    if (!this.trackingEnabled) return { success: true };

    try {
      const changes = this.calculateChanges(oldData, newData);
      
      if (changes.changedFields.length === 0) {
        return { success: true, message: 'Sin cambios detectados' };
      }

      const currentVersion = await this.getCurrentVersion(ratId);
      
      const auditEntry = {
        rat_id: ratId,
        user_id: userId,
        tenant_id: tenantId,
        operation: 'update',
        timestamp: new Date().toISOString(),
        snapshot_before: this.sanitizeSnapshot(oldData),
        snapshot_after: this.sanitizeSnapshot(newData),
        changed_fields: changes.changedFields,
        field_changes: changes.fieldChanges,
        change_summary: this.generateChangeSummary(changes),
        version_number: currentVersion + 1,
        session_id: changeContext.sessionId || this.generateSessionId(),
        ip_address: changeContext.ipAddress,
        user_agent: changeContext.userAgent,
        change_reason: changeContext.reason,
        metadata: {
          change_magnitude: this.assessChangeMagnitude(changes),
          affected_compliance: await this.assessComplianceImpact(changes, newData),
          requires_review: this.requiresReview(changes),
          auto_generated: changeContext.autoGenerated || false
        }
      };

      const { error } = await supabase
        .from('rat_audit_trail')
        .insert(auditEntry);

      if (error) throw error;

      if (auditEntry.metadata.requires_review) {
        await this.flagForReview(ratId, auditEntry, userId);
      }

      return { success: true, auditId: auditEntry.id, changes };
    } catch (error) {
      console.error('Error tracking RAT change');
      return { success: false, error: error.message };
    }
  }

  calculateChanges(oldData, newData) {
    const changes = {
      changedFields: [],
      fieldChanges: {},
      addedFields: [],
      removedFields: []
    };

    const allFields = new Set([
      ...Object.keys(oldData || {}),
      ...Object.keys(newData || {})
    ]);

    for (const field of allFields) {
      const oldValue = oldData?.[field];
      const newValue = newData?.[field];

      if (!this.deepEqual(oldValue, newValue)) {
        changes.changedFields.push(field);
        changes.fieldChanges[field] = {
          before: this.serializeValue(oldValue),
          after: this.serializeValue(newValue),
          changeType: this.determineChangeType(oldValue, newValue)
        };

        if (oldValue === undefined) {
          changes.addedFields.push(field);
        } else if (newValue === undefined) {
          changes.removedFields.push(field);
        }
      }
    }

    return changes;
  }

  deepEqual(a, b) {
    if (a === b) return true;
    if (a == null || b == null) return a === b;
    if (typeof a !== typeof b) return false;
    
    if (typeof a === 'object') {
      if (Array.isArray(a) !== Array.isArray(b)) return false;
      
      if (Array.isArray(a)) {
        if (a.length !== b.length) return false;
        return a.every((item, index) => this.deepEqual(item, b[index]));
      } else {
        const keysA = Object.keys(a);
        const keysB = Object.keys(b);
        if (keysA.length !== keysB.length) return false;
        return keysA.every(key => this.deepEqual(a[key], b[key]));
      }
    }
    
    return false;
  }

  serializeValue(value) {
    if (value === null || value === undefined) return null;
    if (typeof value === 'object') return JSON.stringify(value);
    return String(value);
  }

  determineChangeType(oldValue, newValue) {
    if (oldValue === undefined) return 'added';
    if (newValue === undefined) return 'removed';
    if (Array.isArray(oldValue) && Array.isArray(newValue)) {
      if (newValue.length > oldValue.length) return 'expanded';
      if (newValue.length < oldValue.length) return 'reduced';
      return 'modified';
    }
    return 'modified';
  }

  generateChangeSummary(changes) {
    const { changedFields, addedFields, removedFields } = changes;
    const summaryParts = [];

    if (addedFields.length > 0) {
      summaryParts.push(`Añadido: ${addedFields.join(', ')}`);
    }
    if (removedFields.length > 0) {
      summaryParts.push(`Eliminado: ${removedFields.join(', ')}`);
    }
    
    const modifiedFields = changedFields.filter(
      field => !addedFields.includes(field) && !removedFields.includes(field)
    );
    if (modifiedFields.length > 0) {
      summaryParts.push(`Modificado: ${modifiedFields.join(', ')}`);
    }

    return summaryParts.join(' | ') || 'Cambios menores';
  }

  assessChangeMagnitude(changes) {
    const criticalFields = ['responsable', 'finalidad', 'base_juridica', 'categorias_datos'];
    const highImpactFields = ['transferencias_internacionales', 'decisiones_automatizadas'];
    
    const criticalChanges = changes.changedFields.filter(field => 
      criticalFields.some(critical => field.includes(critical))
    ).length;
    
    const highImpactChanges = changes.changedFields.filter(field =>
      highImpactFields.some(impact => field.includes(impact))
    ).length;

    if (criticalChanges > 2) return 'major';
    if (criticalChanges > 0 || highImpactChanges > 1) return 'significant';
    if (changes.changedFields.length > 5) return 'moderate';
    return 'minor';
  }

  async assessComplianceImpact(changes, newData) {
    const impactAreas = [];

    if (changes.changedFields.includes('categorias_datos')) {
      const oldCategorias = changes.fieldChanges.categorias_datos?.before;
      const newCategorias = changes.fieldChanges.categorias_datos?.after;
      
      if (this.addedSensitiveData(oldCategorias, newCategorias)) {
        impactAreas.push('sensitive_data_added');
      }
    }

    if (changes.changedFields.includes('transferencias_internacionales')) {
      impactAreas.push('international_transfers');
    }

    if (changes.changedFields.includes('base_juridica')) {
      impactAreas.push('legal_basis_change');
    }

    if (changes.changedFields.includes('finalidad')) {
      impactAreas.push('purpose_modification');
    }

    return impactAreas;
  }

  addedSensitiveData(oldCategorias, newCategorias) {
    const sensitiveTypes = ['salud', 'biometrico', 'socioeconomica', 'racial', 'politica', 'religiosa'];
    
    try {
      const oldList = JSON.parse(oldCategorias || '[]');
      const newList = JSON.parse(newCategorias || '[]');
      
      const oldSensitive = oldList.filter(cat => 
        sensitiveTypes.some(type => cat.toLowerCase().includes(type))
      );
      const newSensitive = newList.filter(cat => 
        sensitiveTypes.some(type => cat.toLowerCase().includes(type))
      );
      
      return newSensitive.length > oldSensitive.length;
    } catch (error) {
      return false;
    }
  }

  requiresReview(changes) {
    const criticalChanges = ['responsable', 'base_juridica', 'transferencias_internacionales'];
    return changes.changedFields.some(field => 
      criticalChanges.some(critical => field.includes(critical))
    );
  }

  async flagForReview(ratId, auditEntry, userId) {
    try {
      await supabase
        .from('review_queue')
        .insert({
          rat_id: ratId,
          audit_entry_id: auditEntry.id,
          reason: 'significant_change_detected',
          priority: auditEntry.metadata.change_magnitude === 'major' ? 'high' : 'medium',
          assigned_to: null,
          status: 'pending',
          created_by: userId,
          created_at: new Date().toISOString()
        });
    } catch (error) {
      console.error('Error flagging for review');
    }
  }

  async getCurrentVersion(ratId) {
    try {
      const { data, error } = await supabase
        .from('rat_audit_trail')
        .select('version_number')
        .eq('rat_id', ratId)
        .order('version_number', { ascending: false })
        .limit(1);

      if (error) throw error;
      return data[0]?.version_number || 0;
    } catch (error) {
      console.error('Error obteniendo versión actual');
      return 0;
    }
  }

  async getAuditHistory(ratId, options = {}) {
    try {
      let query = supabase
        .from('rat_audit_trail')
        .select(`
          *,
          users(name, email),
          tenants(company_name)
        `)
        .eq('rat_id', ratId)
        .order('timestamp', { ascending: false });

      if (options.limit) {
        query = query.limit(options.limit);
      }

      if (options.fromDate) {
        query = query.gte('timestamp', options.fromDate);
      }

      if (options.toDate) {
        query = query.lte('timestamp', options.toDate);
      }

      const { data: history, error } = await query;

      if (error) throw error;

      return {
        success: true,
        history: history.map(entry => ({
          ...entry,
          human_readable_summary: this.generateHumanReadableSummary(entry)
        }))
      };
    } catch (error) {
      console.error('Error obteniendo historial');
      return { success: false, error: error.message };
    }
  }

  generateHumanReadableSummary(auditEntry) {
    const user = auditEntry.users?.name || 'Sistema';
    const timestamp = new Date(auditEntry.timestamp).toLocaleString('es-CL');
    
    if (auditEntry.operation === 'create') {
      return `${user} creó el RAT el ${timestamp}`;
    }

    if (auditEntry.operation === 'update') {
      const fields = auditEntry.changed_fields || [];
      const fieldNames = fields.map(field => {
        const fieldTranslations = {
          'responsable': 'responsable',
          'finalidad': 'finalidad',
          'categorias_datos': 'categorías de datos',
          'base_juridica': 'base jurídica',
          'transferencias_internacionales': 'transferencias internacionales',
          'medidas_seguridad': 'medidas de seguridad',
          'plazos_retencion': 'plazos de retención'
        };
        return fieldTranslations[field] || field;
      });

      if (fields.length === 1) {
        return `${user} modificó ${fieldNames[0]} el ${timestamp}`;
      } else if (fields.length <= 3) {
        return `${user} modificó ${fieldNames.join(', ')} el ${timestamp}`;
      } else {
        return `${user} realizó ${fields.length} cambios el ${timestamp}`;
      }
    }

    return `${user} realizó operación ${auditEntry.operation} el ${timestamp}`;
  }

  async getFieldHistory(ratId, fieldName) {
    try {
      const { data: history, error } = await supabase
        .from('rat_audit_trail')
        .select('timestamp, field_changes, user_id, users(name)')
        .eq('rat_id', ratId)
        .contains('changed_fields', [fieldName])
        .order('timestamp', { ascending: false });

      if (error) throw error;

      const fieldHistory = history.map(entry => {
        const fieldChange = entry.field_changes?.[fieldName];
        return {
          timestamp: entry.timestamp,
          user: entry.users?.name || 'Sistema',
          before: fieldChange?.before,
          after: fieldChange?.after,
          changeType: fieldChange?.changeType
        };
      }).filter(item => item.before !== undefined || item.after !== undefined);

      return { success: true, history: fieldHistory };
    } catch (error) {
      console.error('Error obteniendo historial de campo');
      return { success: false, error: error.message };
    }
  }

  async createSnapshot(ratId) {
    try {
      const { data: currentRAT, error } = await supabase
        .from('rats')
        .select('*')
        .eq('id', ratId)
        .single();

      if (error) throw error;

      const snapshot = {
        rat_id: ratId,
        snapshot_data: this.sanitizeSnapshot(currentRAT),
        snapshot_type: 'manual',
        created_at: new Date().toISOString(),
        metadata: {
          snapshot_reason: 'manual_backup',
          data_size: JSON.stringify(currentRAT).length
        }
      };

      const { data, error: insertError } = await supabase
        .from('rat_snapshots')
        .insert(snapshot);

      if (insertError) throw insertError;

      return { success: true, snapshot: data[0] };
    } catch (error) {
      console.error('Error creando snapshot');
      return { success: false, error: error.message };
    }
  }

  async restoreFromSnapshot(ratId, snapshotId, userId, reason = 'manual_restore') {
    try {
      const { data: snapshot, error } = await supabase
        .from('rat_snapshots')
        .select('*')
        .eq('id', snapshotId)
        .single();

      if (error) throw error;

      const { data: currentRAT, error: currentError } = await supabase
        .from('rats')
        .select('*')
        .eq('id', ratId)
        .single();

      if (currentError) throw currentError;

      const { data: restored, error: restoreError } = await supabase
        .from('rats')
        .update(snapshot.snapshot_data)
        .eq('id', ratId);

      if (restoreError) throw restoreError;

      await this.trackRATChange(
        ratId,
        currentRAT,
        snapshot.snapshot_data,
        userId,
        currentRAT.tenant_id,
        {
          reason: reason,
          sessionId: this.generateSessionId(),
          autoGenerated: false,
          restoreFromSnapshot: snapshotId
        }
      );

      return { success: true };
    } catch (error) {
      console.error('Error restaurando snapshot');
      return { success: false, error: error.message };
    }
  }

  async getVersionTimeline(ratId) {
    try {
      const { data: timeline, error } = await supabase
        .from('rat_audit_trail')
        .select(`
          timestamp,
          operation,
          version_number,
          change_summary,
          changed_fields,
          metadata,
          users(name, email)
        `)
        .eq('rat_id', ratId)
        .order('timestamp', { ascending: true });

      if (error) throw error;

      const processedTimeline = timeline.map((entry, index) => ({
        ...entry,
        timeSinceCreation: this.calculateTimeDifference(timeline[0].timestamp, entry.timestamp),
        timeSincePrevious: index > 0 ? 
          this.calculateTimeDifference(timeline[index - 1].timestamp, entry.timestamp) : 
          null,
        isSignificant: entry.metadata?.change_magnitude === 'major' || 
                      entry.metadata?.change_magnitude === 'significant'
      }));

      return { success: true, timeline: processedTimeline };
    } catch (error) {
      console.error('Error obteniendo timeline');
      return { success: false, error: error.message };
    }
  }

  calculateTimeDifference(fromTimestamp, toTimestamp) {
    const from = new Date(fromTimestamp);
    const to = new Date(toTimestamp);
    const diffMs = to - from;
    
    const diffMinutes = Math.floor(diffMs / (1000 * 60));
    const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
    const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));

    if (diffDays > 0) return `${diffDays} día${diffDays > 1 ? 's' : ''}`;
    if (diffHours > 0) return `${diffHours} hora${diffHours > 1 ? 's' : ''}`;
    if (diffMinutes > 0) return `${diffMinutes} minuto${diffMinutes > 1 ? 's' : ''}`;
    return 'ahora mismo';
  }

  async generateAuditReport(ratId, options = {}) {
    try {
      const historyResult = await this.getAuditHistory(ratId, options);
      if (!historyResult.success) throw new Error(historyResult.error);

      const timelineResult = await this.getVersionTimeline(ratId);
      if (!timelineResult.success) throw new Error(timelineResult.error);

      const report = {
        rat_id: ratId,
        generated_at: new Date().toISOString(),
        total_versions: timelineResult.timeline.length,
        creation_date: timelineResult.timeline[0]?.timestamp,
        last_modified: timelineResult.timeline[timelineResult.timeline.length - 1]?.timestamp,
        total_users_involved: [...new Set(historyResult.history.map(h => h.user_id))].length,
        significant_changes: timelineResult.timeline.filter(t => t.isSignificant).length,
        compliance_impacts: this.analyzeComplianceImpacts(historyResult.history),
        summary: this.generateReportSummary(timelineResult.timeline, historyResult.history)
      };

      await this.saveAuditReport(report);
      return { success: true, report };
    } catch (error) {
      console.error('Error generando reporte de auditoría');
      return { success: false, error: error.message };
    }
  }

  analyzeComplianceImpacts(history) {
    const impacts = [];
    
    history.forEach(entry => {
      if (entry.metadata?.affected_compliance) {
        impacts.push(...entry.metadata.affected_compliance);
      }
    });

    const uniqueImpacts = [...new Set(impacts)];
    return uniqueImpacts.map(impact => ({
      type: impact,
      count: impacts.filter(i => i === impact).length,
      latest_occurrence: history.find(h => 
        h.metadata?.affected_compliance?.includes(impact)
      )?.timestamp
    }));
  }

  generateReportSummary(timeline, history) {
    const majorChanges = timeline.filter(t => t.metadata?.change_magnitude === 'major').length;
    const reviewFlags = history.filter(h => h.metadata?.requires_review).length;
    const autoChanges = history.filter(h => h.metadata?.auto_generated).length;

    return {
      total_changes: timeline.length - 1,
      major_changes: majorChanges,
      review_flags: reviewFlags,
      automated_changes: autoChanges,
      manual_changes: timeline.length - 1 - autoChanges,
      compliance_reviews_triggered: reviewFlags
    };
  }

  async saveAuditReport(report) {
    try {
      await supabase
        .from('audit_reports')
        .insert({
          rat_id: report.rat_id,
          report_data: report,
          generated_at: report.generated_at,
          report_type: 'temporal_audit'
        });
    } catch (error) {
      console.error('Error guardando reporte de auditoría');
    }
  }

  async deleteOldAuditEntries(retentionDays = 365) {
    try {
      const cutoffDate = new Date();
      cutoffDate.setDate(cutoffDate.getDate() - retentionDays);

      const { error } = await supabase
        .from('rat_audit_trail')
        .delete()
        .lt('timestamp', cutoffDate.toISOString())
        .neq('metadata->initial_state', true);

      if (error) throw error;

      return { success: true };
    } catch (error) {
      console.error('Error eliminando entradas antigas');
      return { success: false, error: error.message };
    }
  }

  sanitizeSnapshot(data) {
    if (!data) return null;

    const sanitized = JSON.parse(JSON.stringify(data));
    
    const sensitiveFields = ['password', 'token', 'secret', 'api_key'];
    this.removeSensitiveFields(sanitized, sensitiveFields);
    
    return sanitized;
  }

  removeSensitiveFields(obj, sensitiveFields) {
    if (typeof obj !== 'object' || obj === null) return;

    Object.keys(obj).forEach(key => {
      if (sensitiveFields.some(field => key.toLowerCase().includes(field))) {
        obj[key] = '[REDACTED]';
      } else if (typeof obj[key] === 'object') {
        this.removeSensitiveFields(obj[key], sensitiveFields);
      }
    });
  }

  generateSessionId() {
    return `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  async enableTracking(userId) {
    try {
      await supabase
        .from('system_config')
        .upsert({
          key: 'temporal_audit_enabled',
          value: 'true',
          updated_by: userId,
          updated_at: new Date().toISOString()
        });

      this.trackingEnabled = true;
      return { success: true, message: 'Auditoría temporal habilitada' };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }

  async disableTracking(userId) {
    try {
      await supabase
        .from('system_config')
        .upsert({
          key: 'temporal_audit_enabled',
          value: 'false',
          updated_by: userId,
          updated_at: new Date().toISOString()
        });

      this.trackingEnabled = false;
      return { success: true, message: 'Auditoría temporal deshabilitada' };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }

  async getComplianceAuditSummary(tenantId, days = 30) {
    try {
      const { data: entries, error } = await supabase
        .from('rat_audit_trail')
        .select('*')
        .eq('tenant_id', tenantId)
        .gte('timestamp', new Date(Date.now() - days * 24 * 60 * 60 * 1000).toISOString());

      if (error) throw error;

      const summary = {
        total_changes: entries.length,
        rats_modified: [...new Set(entries.map(e => e.rat_id))].length,
        compliance_impacts: 0,
        review_flags: 0,
        automated_changes: 0,
        user_changes: 0,
        change_frequency: this.calculateChangeFrequency(entries),
        top_changed_fields: this.getTopChangedFields(entries),
        most_active_users: this.getMostActiveUsers(entries)
      };

      entries.forEach(entry => {
        if (entry.metadata?.affected_compliance?.length > 0) {
          summary.compliance_impacts++;
        }
        if (entry.metadata?.requires_review) {
          summary.review_flags++;
        }
        if (entry.metadata?.auto_generated) {
          summary.automated_changes++;
        } else {
          summary.user_changes++;
        }
      });

      return { success: true, summary };
    } catch (error) {
      console.error('Error generando resumen de auditoría');
      return { success: false, error: error.message };
    }
  }

  calculateChangeFrequency(entries) {
    const dailyChanges = {};
    entries.forEach(entry => {
      const date = entry.timestamp.split('T')[0];
      dailyChanges[date] = (dailyChanges[date] || 0) + 1;
    });

    const dates = Object.keys(dailyChanges);
    if (dates.length === 0) return 0;

    const totalChanges = Object.values(dailyChanges).reduce((sum, count) => sum + count, 0);
    return Math.round(totalChanges / dates.length * 10) / 10;
  }

  getTopChangedFields(entries) {
    const fieldCounts = {};
    entries.forEach(entry => {
      (entry.changed_fields || []).forEach(field => {
        fieldCounts[field] = (fieldCounts[field] || 0) + 1;
      });
    });

    return Object.entries(fieldCounts)
      .sort(([,a], [,b]) => b - a)
      .slice(0, 5)
      .map(([field, count]) => ({ field, count }));
  }

  getMostActiveUsers(entries) {
    const userCounts = {};
    entries.forEach(entry => {
      if (entry.user_id) {
        userCounts[entry.user_id] = (userCounts[entry.user_id] || 0) + 1;
      }
    });

    return Object.entries(userCounts)
      .sort(([,a], [,b]) => b - a)
      .slice(0, 3)
      .map(([userId, count]) => ({ userId, count }));
  }

  async triggerPeriodicSnapshot(tenantId) {
    try {
      const { data: activeRATs, error } = await supabase
        .from('rats')
        .select('id')
        .eq('tenant_id', tenantId)
        .eq('estado', 'activo');

      if (error) throw error;

      const results = [];
      for (const rat of activeRATs) {
        const result = await this.createSnapshot(rat.id);
        results.push({ ratId: rat.id, success: result.success });
      }

      return {
        success: true,
        snapshots_created: results.filter(r => r.success).length,
        total_rats: activeRATs.length
      };
    } catch (error) {
      console.error('Error en snapshot periódico');
      return { success: false, error: error.message };
    }
  }

  async cleanupAuditData(retentionPolicy = { days: 365, keepSnapshots: true }) {
    try {
      const results = {
        audit_entries_deleted: 0,
        snapshots_deleted: 0,
        reports_deleted: 0
      };

      const cutoffDate = new Date();
      cutoffDate.setDate(cutoffDate.getDate() - retentionPolicy.days);

      const { data: deletedAudit, error: auditError } = await supabase
        .from('rat_audit_trail')
        .delete()
        .lt('timestamp', cutoffDate.toISOString())
        .neq('metadata->initial_state', true);

      if (!auditError) {
        results.audit_entries_deleted = deletedAudit?.length || 0;
      }

      if (!retentionPolicy.keepSnapshots) {
        const { data: deletedSnapshots, error: snapshotError } = await supabase
          .from('rat_snapshots')
          .delete()
          .lt('created_at', cutoffDate.toISOString())
          .neq('snapshot_type', 'milestone');

        if (!snapshotError) {
          results.snapshots_deleted = deletedSnapshots?.length || 0;
        }
      }

      const { data: deletedReports, error: reportError } = await supabase
        .from('audit_reports')
        .delete()
        .lt('generated_at', cutoffDate.toISOString());

      if (!reportError) {
        results.reports_deleted = deletedReports?.length || 0;
      }

      return { success: true, cleanup_results: results };
    } catch (error) {
      console.error('Error en limpieza de auditoría');
      return { success: false, error: error.message };
    }
  }
}

const temporalAudit = new TemporalAudit();

export default temporalAudit;